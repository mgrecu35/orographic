subroutine computeZ(pRate,fint,pZ_snow,pZ_rain,att_snow,att_rain,n,dr,&
     z_att)
  implicit none
  real :: pRate(n),fint(n), dr
  real, intent(out) :: z_att(n)
  real  :: pZ_snow(2), pZ_rain(2), att_snow(2), att_rain(2)
  integer :: n, i
  real :: snowRate(n),rainRate(n), attRain(n),attSnow(n), att_tot(n)
  real :: pia_tot
  real :: zSnow(n), zRain(n), z_tot(n)

  pia_tot=0

  do i=n,1,-1
     snowRate(i)=(1-fint(i))*pRate(i)
     zSnow(i)=pZ_snow(1)*log(snowRate(i)+1e-3)+pZ_snow(2)
     attSnow(i)=exp(att_snow(1)*log(snowRate(i)+1e-3)+att_snow(2))
     rainRate(i)=fint(i)*pRate(i)
     zRain(i)=pZ_rain(1)*log(rainRate(i)+1e-3)+pZ_rain(2)
     z_tot(i)=10*log10(10**(0.1*zSnow(i))+10**(0.1*zRain(i)))
     attRain(i)=exp(att_rain(1)*log(rainRate(i)+1e-3)+att_rain(2))
     att_tot(i)=(attSnow(i)+attRain(i))*dr
     pia_tot=pia_tot+att_tot(i)
     z_att(i)=z_tot(i)-pia_tot
     pia_tot=pia_tot+att_tot(i)
  end do
end subroutine computeZ

!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 31 May 2021 11:17
!
!  Differentiation of computez in forward (tangent) mode:
!   variations   of useful results: z_att
!   with respect to varying inputs: prate
!   RW status of diff variables: z_att:out prate:in

SUBROUTINE computez_d(prate, prated, fint, pz_snow, pz_rain, att_snow, &
& att_rain, n, dr, z_att, z_attd)
  IMPLICIT NONE
  INTEGER :: n, i
  REAL :: prate(n), fint(n), dr
  REAL :: prated(n)
  REAL, INTENT(OUT) :: z_att(n)
  REAL, INTENT(OUT) :: z_attd(n,n)
  REAL :: pz_snow(2), pz_rain(2), att_snow(2), att_rain(2)
  REAL :: snowrate(n), rainrate(n), attrain(n), attsnow(n), att_tot(n)
  REAL :: snowrated(n), rainrated(n), attraind(n), attsnowd(n), att_totd&
& (n)
  REAL :: pia_tot
  REAL :: pia_totd
  REAL :: zsnow(n), zrain(n), z_tot(n)
  REAL :: zsnowd(n), zraind(n), z_totd(n)
  INTRINSIC LOG
  INTRINSIC EXP
  INTRINSIC LOG10
  REAL :: arg1
  REAL :: arg1d
  REAL :: pwy1
  REAL :: pwy1d
  REAL :: pwr1
  REAL :: pwr1d
  REAL :: pwy2
  REAL :: pwy2d
  REAL :: pwr2
  REAL :: pwr2d
  REAL :: temp
  pia_tot = 0
  z_attd = 0.0
  zraind = 0.0
  attsnowd = 0.0
  pia_totd = 0.0
  z_totd = 0.0
  attraind = 0.0
  snowrated = 0.0
  rainrated = 0.0
  att_totd = 0.0
  zsnowd = 0.0
  DO i=n,1,-1
    snowrated(i) = (1-fint(i))*prated(i)
    snowrate(i) = (1-fint(i))*prate(i)
    zsnowd(i) = pz_snow(1)*snowrated(i)/(snowrate(i)+1e-3)
    zsnow(i) = pz_snow(1)*LOG(snowrate(i)+1e-3) + pz_snow(2)
    arg1d = att_snow(1)*snowrated(i)/(snowrate(i)+1e-3)
    arg1 = att_snow(1)*LOG(snowrate(i)+1e-3) + att_snow(2)
    attsnowd(i) = EXP(arg1)*arg1d
    attsnow(i) = EXP(arg1)
    rainrated(i) = fint(i)*prated(i)
    rainrate(i) = fint(i)*prate(i)
    zraind(i) = pz_rain(1)*rainrated(i)/(rainrate(i)+1e-3)
    zrain(i) = pz_rain(1)*LOG(rainrate(i)+1e-3) + pz_rain(2)
    pwy1d = 0.1*zsnowd(i)
    pwy1 = 0.1*zsnow(i)
    temp = 10**pwy1
    pwr1d = temp*LOG(10.0)*pwy1d
    pwr1 = temp
    pwy2d = 0.1*zraind(i)
    pwy2 = 0.1*zrain(i)
    temp = 10**pwy2
    pwr2d = temp*LOG(10.0)*pwy2d
    pwr2 = temp
    z_totd(i) = 10*(pwr1d+pwr2d)/((pwr1+pwr2)*LOG(10.0))
    z_tot(i) = 10*LOG10(pwr1+pwr2)
    arg1d = att_rain(1)*rainrated(i)/(rainrate(i)+1e-3)
    arg1 = att_rain(1)*LOG(rainrate(i)+1e-3) + att_rain(2)
    attraind(i) = EXP(arg1)*arg1d
    attrain(i) = EXP(arg1)
    att_totd(i) = dr*(attsnowd(i)+attraind(i))
    att_tot(i) = (attsnow(i)+attrain(i))*dr
    pia_totd = pia_totd + att_totd(i)
    pia_tot = pia_tot + att_tot(i)
    z_attd(i,i) = z_attd(i,i)- att_totd(i)
    z_attd(1:i-1,i)=z_attd(1:i-1,i)-2*att_totd(i)
    z_att(i) = z_tot(i) - pia_tot
    pia_totd = pia_totd + att_totd(i)
    pia_tot = pia_tot + att_tot(i)
  END DO
END SUBROUTINE computez_d
